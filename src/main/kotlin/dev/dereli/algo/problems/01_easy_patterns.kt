package dev.dereli.algo.problems

/*
============================================================
EASY PATTERNS (база собеседований): 4 классические задачи
Kotlin / алгоритмическое мышление / оценка сложности
============================================================

0) Общая идея:
- В easy-задачах почти всегда важно узнать паттерн:
  HashMap/Set, Stack, One-pass, Two pointers, Prefix sums, Binary search.

- Что обычно спрашивают на собесе:
  1) Какую структуру данных выбираешь и почему?
  2) Сложность: O(n)? O(n log n)? Память?
  3) Крайние случаи (пустой массив, повторяющиеся элементы, отрицательные числа).
  4) Читаемый код + аккуратные названия.

Ниже: 4 задачи и 4 паттерна.
*/


/* ============================================================
1) TWO SUM (HashMap: value -> index)
===============================================================
Задача:
- Дано nums и target.
- Нужно вернуть индексы i, j: nums[i] + nums[j] == target.
- Обычно гарантируется, что ответ существует и нельзя использовать один и тот же элемент дважды.

Ключевая идея (паттерн "HashMap индексов"):
- На каждом шаге смотрим текущий элемент x.
- Мы хотим найти "комплемент" need = target - x.
- Если need уже встречался, значит есть ответ: (indexOfNeed, currentIndex).
- Иначе сохраняем x -> индекс.

Почему это O(n):
- Мы делаем один проход.
- Доступ в HashMap в среднем O(1).

Важно:
- Сначала проверяем need, потом кладём текущий элемент в map,
  чтобы не использовать один и тот же элемент дважды.
- Работает с отрицательными числами и повторами.

Сложность:
- Time: O(n)
- Space: O(n)
*/
fun twoSum(nums: IntArray, target: Int): IntArray {
    // seen хранит: "значение элемента" -> "индекс, где оно встречалось"
    val seen = HashMap<Int, Int>(nums.size)
    for (i in nums.indices) {
        val x = nums[i]
        // Ищем число, которое должно дополнить x до таргета
        val need = target - nums[i]
        // Если need уже встречали, достаём его индекс и возвращаем ответ
        val j = seen[need]

        if (j != null) {
            // j < i, потому что need мы встретили раньше
            return intArrayOf(j, i)
        }
        // Иначе запоминаем текущий элемент для будущих шагов
        seen[x] = i
    }

    // Если ответ гарантирован, то сюда мы не зайдём
    // Но всё равно вернём пустой массив, или можно ещё кинуть исключение
    return intArrayOf()
}

/* ============================================================
2) VALID ANAGRAM (частоты символов)
===============================================================
Задача:
- Даны строки s и t.
- Нужно проверить, являются ли они анаграммами:
  т.е. содержат одинаковые символы в одинаковых количествах (порядок не важен).

Ключевая идея (паттерн "Frequency Count"):
- Счётчик частот для каждого символа.
- Увеличиваем частоты по s.
- Уменьшаем по t.
- Если где-то ушли в минус → t содержит символов больше, чем s → не анаграмма.
- В конце все частоты должны быть 0.

Варианты реализации:
A) Если только 'a'..'z' (часто в LeetCode):
   IntArray(26) — самый быстрый и простой.
B) Если Unicode/любой алфавит:
   HashMap<Char, Int> или IntArray по диапазону (дороже).

Сложность:
- Time: O(n)
- Space: O(1) для фиксированного алфавита (26)
         O(k) для HashMap, где k — число разных символов
*/
fun isAnagram(s: String, t: String): Boolean {
    // Быстро проверим, что длины строк одинаковы. Если нет -> точно не анаграмма
    if (s.length != t.length) return false

    // Счётчик для английских строчных букв a..z
    val freq = IntArray(26)

    // Считаем частоты символов в s
    for (char in s) {
        freq[char - 'a']++
    }

    // Вычитаем частоты символов t
    for (char in t) {
        val idx = char - 'a'
        freq[idx]--
        // Если где-то ушли в минус, то точно не анаграммы
        if (freq[idx] < 0) return false
    }

    // Длины равны + нигде не ушли в минус. Анаграммы
    return true
}


//Вариант для любых символов, с HashMap
fun isAnagramAnyChars(s: String, t: String): Boolean {
    if (s.length != t.length) return false
    val map = HashMap<Char, Int>()
    for (char in s) {
        map[char] = (map[char] ?: 0) + 1
    }

    for (char in t) {
        val v = (map[char] ?: return false) - 1
        if (v == 0) map.remove(char) else map[char] = v
    }
    return map.isEmpty()
}

/* ============================================================
3) BEST TIME TO BUY AND SELL STOCK (one pass)
===============================================================
Задача:
- Дан массив prices, где prices[i] — цена акции в день i.
- Нужно максимизировать прибыль: купить один раз и продать один раз (после покупки).
- Вернуть максимальную прибыль, либо 0 если выгодной сделки нет.

Ключевая идея (паттерн "One pass + хранение лучшего состояния"):
- На каждом шаге нам важно:
  1) минимальная цена, которую мы видели раньше (лучшая покупка)
  2) текущая лучшая прибыль

Алгоритм:
- minPrice = +inf
- bestProfit = 0
- Для каждой цены p:
  - если p < minPrice → обновить minPrice
  - иначе profit = p - minPrice, обновить bestProfit

Почему это правильно:
- Для продажи в день i лучшая покупка — это минимальная цена на днях < i.
- Мы эту минимальную цену поддерживаем в minPrice.

Сложность:
- Time: O(n)
- Space: O(1)
*/
fun maxProfit(prices: IntArray): Int {
    var minPrice = Int.MAX_VALUE
    var best = 0

    for (p in prices) {
        if (p < minPrice) {
            minPrice = p
            continue
        }

        if (p - minPrice > best) {
            best = p - minPrice
        }
    }
    return best
}

/* ============================================================
4) VALID PARENTHESES (Stack)
===============================================================
Задача:
- Дана строка s из символов: ()[]{}.
- Нужно проверить, что скобки корректно закрыты:
  1) Каждой открывающей соответствует закрывающая того же типа
  2) Порядок соблюдён (LIFO): последняя открытая должна закрыться первой
  3) Нельзя закрыть, если не было открывающей

Ключевая идея (паттерн "Stack / ArrayDeque"):
- Встречаем открывающую → кладём в стек.
- Встречаем закрывающую → достаём верх стека и проверяем пару.
- В конце стек должен быть пуст.

Почему Stack:
- Потому что “вложенность” — это LIFO.

Сложность:
- Time: O(n)
- Space: O(n) в худшем случае (все открывающие)

Kotlin нюанс:
- Удобно использовать ArrayDeque<Char>()
- removeLastOrNull() — безопасно: вернёт null, если стек пуст
*/
fun isValid(s: String): Boolean {
    val st = ArrayDeque<Char>() // стек открывающих скобок
    for (char in s) {
        when (char) {
             // открывающие ставим в стек
            '(', '{', '[' -> st.addLast(char)
            // Закрывающие проверяем на соответствие верхушке стека
            ')' -> {
                // Если стек пуст или не та скобка - возвращаем false
                if (st.removeLastOrNull() != '(') return false
            }

            '}' -> {
                if (st.removeLastOrNull() != '{') return false
            }

            ']' -> {
                if (st.removeLastOrNull() != '[') return false
            }
            // Если наткнулись на какой-то не такой символ - кидаем false
            else -> return false
        }
    }
    // Если ещё что-то осталось - кидаем false
    return st.isEmpty()
}
